#pragma once
#include <string>
#include <variant>
#include <optional>

class SharedType
{
private:
    std::variant<float, std::string> value_;

public:
    /* --------------- Constructors --------------- */
    SharedType() = default;

    // Direct construction from a float or a string
    SharedType(float v)  : value_(v) {}
    SharedType(const std::string& s) : value_(s) {}
    SharedType(std::string&& s) : value_(std::move(s)) {}

    /* --------------- set_value --------------- */
    // Overload for each supported type
    void set_value(float v)  { value_ = v; }
    void set_value(const std::string& s) { value_ = s; }
    void set_value(std::string&& s)      { value_ = std::move(s); }

    /* --------------- get_value --------------- */
    // Get the whole variant (readâ€‘only)
    const std::variant<float, std::string>& get() const noexcept { return value_; }

    // Try to extract the stored value as a concrete type.
    // Returns std::nullopt if the type does not match.
    template<class T>
    std::optional<T> get() const
    {
        if (auto p = std::get_if<T>(&value_))
            return *p;
        return std::nullopt;
    }

    // Convenience helper to use std::visit
    template<class Visitor>
    auto visit(Visitor&& v) const -> decltype(std::visit(std::forward<Visitor>(v), value_))
    {
        return std::visit(std::forward<Visitor>(v), value_);
    }
};
